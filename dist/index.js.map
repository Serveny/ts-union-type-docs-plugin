{"version":3,"file":"index.js","sources":["../src/docs.ts","../src/info.ts","../src/plugin.ts","../src/index.ts"],"sourcesContent":["import type * as TS from 'typescript/lib/tsserverlibrary';\nimport { CalledNode, UnionInfo } from './info';\n\ntype TagIdx = {\n\ttag: TS.JSDocTagInfo;\n\tidx: number;\n};\n\nexport function addExtraJSDocTagInfo(\n\tts: typeof TS,\n\tquickInfo: TS.QuickInfo,\n\ttypesInfo: UnionInfo[]\n) {\n\tif (typesInfo.length === 0) return;\n\ttypesInfo.forEach((p) => addDocComment(ts, p));\n\n\tif (!quickInfo.tags) quickInfo.tags = [];\n\n\tconst tagIdxs: TagIdx[] =\n\t\tquickInfo.tags\n\t\t\t?.map((tag, idx) => ({ tag, idx }))\n\t\t\t.filter((ti) => ti.tag.name === 'param') ?? [];\n\n\t// Create new tag list to prevent tags stacking up over time in quick info\n\tconst newTags = [\n\t\t...(tagIdxs.length > 0\n\t\t\t? quickInfo.tags.filter((_, i) => i < tagIdxs[0].idx)\n\t\t\t: quickInfo.tags),\n\t];\n\n\tfor (const paramInfo of typesInfo) {\n\t\tconst jsDocTag = findJsDocParamTagByName(tagIdxs, paramInfo.name);\n\n\t\t// If type info found, create new quick info tag\n\t\tif ((paramInfo.docComment?.length ?? 0) > 0) {\n\t\t\t// If no js doc comment for param found, fill with default\n\t\t\tconst newTag = addParamTagInfo(\n\t\t\t\tjsDocTag?.tag ?? defaultParamJSDocTag(paramInfo.name),\n\t\t\t\tparamInfo\n\t\t\t);\n\t\t\tnewTags.push(newTag);\n\t\t}\n\t}\n\n\t// If tags after last param tag left, add them to new tag list\n\tconst lastParamTagIdx =\n\t\ttagIdxs.length === 0 ? 0 : tagIdxs[tagIdxs.length - 1]?.idx ?? 0;\n\tif (quickInfo.tags.length - 1 > lastParamTagIdx)\n\t\tnewTags.push(...quickInfo.tags.filter((_, i) => i > lastParamTagIdx));\n\n\tquickInfo.tags = newTags;\n}\n\nfunction findJsDocParamTagByName(tags: TagIdx[], name: string): TagIdx | null {\n\tconst foundTag = tags.find(({ tag }) =>\n\t\ttag.text?.some(\n\t\t\t(textPart) =>\n\t\t\t\ttextPart.kind === 'parameterName' &&\n\t\t\t\ttextPart.text.toLowerCase() === name.toLowerCase()\n\t\t)\n\t);\n\treturn foundTag ?? null;\n}\n\nfunction defaultParamJSDocTag(name: string): TS.JSDocTagInfo {\n\treturn {\n\t\tname: 'param',\n\t\ttext: [\n\t\t\t{\n\t\t\t\tkind: 'parameterName',\n\t\t\t\ttext: name,\n\t\t\t},\n\t\t],\n\t} as TS.JSDocTagInfo;\n}\n\nfunction createMarkdownDisplayPart(mdText: string): TS.SymbolDisplayPart {\n\treturn {\n\t\ttext: mdText,\n\t\tkind: 'markdown',\n\t} as TS.SymbolDisplayPart;\n}\n\nfunction addParamTagInfo(\n\toldTag: TS.JSDocTagInfo,\n\ttypeInfo: UnionInfo | undefined\n): TS.JSDocTagInfo {\n\tconst newTag: TS.JSDocTagInfo = JSON.parse(JSON.stringify(oldTag));\n\tif (!typeInfo?.docComment) return newTag;\n\tif (!newTag.text) newTag.text = [];\n\tnewTag.text!.push(\n\t\tcreateMarkdownDisplayPart(\n\t\t\ttypeInfo.docComment\n\t\t\t\t?.map((line, i) => (i > 0 ? (line = '> ' + line) : line))\n\t\t\t\t.join('\\n')\n\t\t)\n\t);\n\treturn newTag;\n}\n\nfunction addDocComment(ts: typeof TS, param: UnionInfo) {\n\tconst visited = new Set();\n\tconst comments: string[][] = [];\n\n\t// Read out all comments\n\tfor (const entryNode of param.entries) {\n\t\tif (visited.has(entryNode.id)) continue;\n\t\tvisited.add(entryNode.id);\n\t\tcomments.push(extractJSDocsFromNode(ts, entryNode));\n\n\t\tlet parent = entryNode.callParent;\n\t\twhile (parent != null) {\n\t\t\tif (!visited.has(parent.id)) {\n\t\t\t\tcomments.push(extractJSDocsFromNode(ts, parent));\n\t\t\t\tvisited.add(parent.id);\n\t\t\t}\n\t\t\tparent = parent.callParent;\n\t\t}\n\t}\n\n\t// Add the comments in order parent -> ... -> child\n\tconst lines = comments.reverse().flat();\n\tif (!param.docComment) param.docComment = lines;\n\telse param.docComment.push(...lines);\n}\n\nfunction extractJSDocsFromNode(ts: typeof TS, node: CalledNode): string[] {\n\t// If the node was resolved, get the original node\n\tnode = node.original ?? node;\n\tconst sourceFile = node.getSourceFile();\n\tif (!sourceFile) return [];\n\tconst sourceText = sourceFile.getFullText();\n\tconst start = node.getStart();\n\tconst comment = getLeadingComment(ts, sourceText, start);\n\n\treturn comment\n\t\t? prepareJSDocText(sourceText.substring(comment.pos, comment.end))\n\t\t: [];\n}\n\nfunction getLeadingComment(\n\tts: typeof TS,\n\ttext: string,\n\tpos: number\n): TS.CommentRange | undefined {\n\tconst comments = ts.getLeadingCommentRanges(text, pos) ?? [];\n\n\t// jsdoc comment (has to start with /**)\n\tif (comments.length > 0 && text[comments[0].pos + 2] === '*')\n\t\treturn comments[comments.length - 1];\n\n\ttext = text.substring(0, pos);\n\tconst commentStart = text.lastIndexOf('/**');\n\tif (commentStart === -1) return;\n\n\tconst commentEnd = text.lastIndexOf('*/');\n\tif (commentEnd === -1) return;\n\n\t// only spaces, tabs or linebreaks allowed between comment and node\n\tconst textBetween = text.substring(commentEnd + 2, pos);\n\tif (/[^ \\t|\\n]/.test(textBetween)) return;\n\n\treturn {\n\t\tpos: commentStart + 3,\n\t\tend: commentEnd,\n\t\tkind: ts.SyntaxKind.MultiLineCommentTrivia,\n\t};\n}\n\nfunction prepareJSDocText(rawComment: string): string[] {\n\treturn (\n\t\trawComment\n\t\t\t.replace('/**', '')\n\t\t\t.replace('*/', '')\n\t\t\t.split('\\n')\n\t\t\t// remove whitespace and the leading * in every line\n\t\t\t.map((line) => line.trim().replace(/^\\* ?/, ''))\n\t\t\t// make @tags cursive again\n\t\t\t.map((line) => line.replace(/@(\\w+)/g, (_, tag) => `\\n> _@${tag}_`))\n\t);\n}\n","import type * as TS from 'typescript/lib/tsserverlibrary';\n\nexport enum SupportedType {\n\tParamter,\n}\n\n// This class holds every type information the plugin needs\nexport class UnionInfo {\n\tconstructor(\n\t\tpublic type: SupportedType,\n\t\tpublic name: string,\n\t\t// Can be multiple nodes because different union types can have same values\n\t\tpublic entries: CalledNode[],\n\t\tpublic value?: string,\n\t\tpublic docComment?: string[]\n\t) {}\n}\n\nexport interface CalledNode extends TS.Node {\n\tid?: string;\n\tcallParent?: CalledNode; // The node that references to it\n\toriginal?: TS.Node; // For resolved nodes\n\tisRegexPattern?: boolean; // For template syntax like ${number}\n}\n\nexport class TypeInfoFactory {\n\tprivate checker!: TS.TypeChecker;\n\n\tconstructor(private ts: typeof TS, private ls: TS.LanguageService) {}\n\n\tcreate(fileName: string, position: number): UnionInfo[] | null {\n\t\tconst program = this.ls.getProgram();\n\t\tif (!program) return null;\n\n\t\tthis.checker = program.getTypeChecker();\n\t\tif (!this.checker) return null;\n\n\t\tconst source = program.getSourceFile(fileName);\n\t\tif (!source) return null;\n\n\t\tconst node = this.findNodeAtPos(source, position);\n\t\tif (!node) return null;\n\n\t\tconst symbol = this.checker.getSymbolAtLocation(node);\n\t\tif (!symbol) return null;\n\n\t\t// Find union type parameter info for function call\n\t\tconst callExpression = this.getCallExpression(node);\n\t\tif (callExpression) return this.getUnionParamtersInfo(callExpression);\n\n\t\t// TODO: Find union type info for variable\n\t\treturn null;\n\t}\n\n\tprivate findNodeAtPos(srcFile: TS.SourceFile, pos: number): TS.Node | null {\n\t\tconst find = (node: TS.Node): TS.Node | null =>\n\t\t\tpos >= node.getStart() && pos < node.getEnd()\n\t\t\t\t? this.ts.forEachChild(node, find) || node\n\t\t\t\t: null;\n\t\treturn find(srcFile);\n\t}\n\n\tprivate getCallExpression(node: TS.Node): TS.CallExpression | null {\n\t\tif (this.ts.isCallExpression(node)) return node;\n\t\twhile (node && !this.ts.isCallExpression(node)) node = node.parent;\n\t\treturn node;\n\t}\n\n\tprivate getUnionParamtersInfo(callExpr: TS.CallExpression): UnionInfo[] {\n\t\tconst paramTypes: UnionInfo[] = [];\n\t\tconst signature = this.checker.getResolvedSignature(callExpr);\n\t\tif (!signature) return paramTypes;\n\n\t\tconst args = callExpr.arguments;\n\t\tconst params = signature.getParameters();\n\t\tfor (let i = 0; i < params.length; i++) {\n\t\t\tconst paramInfo = this.getUnionInfo(params[i], args[i]);\n\t\t\tif (paramInfo) paramTypes.push(paramInfo);\n\t\t}\n\n\t\treturn paramTypes;\n\t}\n\n\tprivate getUnionInfo(\n\t\tparamSymbol: TS.Symbol,\n\t\targ: TS.Expression\n\t): UnionInfo | null {\n\t\tconst decl = paramSymbol.valueDeclaration;\n\t\tif (!decl || !this.ts.isParameter(decl) || !decl.type) return null;\n\n\t\tconst unionMemberNodes = this.collectUnionMemberNodes(decl.type);\n\t\tif (unionMemberNodes.length === 0) return null;\n\n\t\tconst value = this.getValue(arg);\n\t\tconst valueNodes = unionMemberNodes.filter((entry) => this.cmp(arg, entry));\n\n\t\treturn new UnionInfo(\n\t\t\tSupportedType.Paramter,\n\t\t\tparamSymbol.name,\n\t\t\tvalueNodes,\n\t\t\tvalue\n\t\t);\n\t}\n\n\tprivate getValue(expr: TS.Expression): string {\n\t\treturn this.ts.isLiteralExpression(expr) ? expr.text : expr.getText();\n\t}\n\n\tprivate collectUnionMemberNodes(\n\t\tnode: TS.Node,\n\t\tcallParent?: TS.Node\n\t): CalledNode[] {\n\t\tconst ts = this.ts;\n\n\t\tif (\n\t\t\tts.isUnionTypeNode(node) || // e.g. string | number\n\t\t\tts.isIntersectionTypeNode(node) || // e.g. Class1 & Class2\n\t\t\tts.isHeritageClause(node) // e.g. Class1 extends BaseClass implements Interface1\n\t\t) {\n\t\t\treturn node.types\n\t\t\t\t.map((tn) => this.collectUnionMemberNodes(tn, callParent))\n\t\t\t\t.flat();\n\t\t}\n\n\t\t// e.g. T extends U ? string : number\n\t\tif (ts.isConditionalTypeNode(node))\n\t\t\treturn this.collectConditionalTypeNode(node);\n\n\t\t// e.g. Object1[\"propName\"]\n\t\tif (ts.isIndexedAccessTypeNode(node))\n\t\t\treturn this.collectIndexedAccessTypeNode(node);\n\n\t\t// e.g. { prop1: string; prop2: number }\n\t\tif (ts.isTypeLiteralNode(node)) return this.collectTypeLiteralNode(node);\n\n\t\t// e.g. { [K in keyof T]: T[K] }\n\t\tif (ts.isMappedTypeNode(node)) return this.collectMappedTypeNode(node);\n\n\t\t// e.g. Promise<string>\n\t\tif (ts.isTypeReferenceNode(node))\n\t\t\treturn this.collectTypeReferenceNode(node);\n\n\t\t// e.g. keyof Class1\n\t\tif (\n\t\t\tts.isTypeOperatorNode(node) &&\n\t\t\tnode.operator === ts.SyntaxKind.KeyOfKeyword\n\t\t)\n\t\t\treturn this.collectKeyOfKeywordTypeOperatorNode(node, callParent);\n\n\t\t// e.g. (string | number)[]\n\t\tif (ts.isParenthesizedTypeNode(node))\n\t\t\treturn this.collectUnionMemberNodes(node.type, node);\n\n\t\t// e.g. string[]\n\t\tif (ts.isArrayTypeNode(node))\n\t\t\treturn this.collectUnionMemberNodes(node.elementType, node);\n\n\t\t// e.g. [string, number, boolean]\n\t\tif (ts.isTupleTypeNode(node)) return this.collectTupleTypeNode(node);\n\n\t\t// e.g. typeof var1\n\t\tif (ts.isTypeQueryNode(node)) return this.collectTypeQueryNode(node);\n\n\t\t// e.g. `text-${number}`\n\t\tif (ts.isTemplateLiteralTypeNode(node))\n\t\t\treturn this.buildTemplateLiteralNode(node, callParent);\n\n\t\t// This is the end of the journey\n\t\tif (\n\t\t\tts.isLiteralTypeNode(node) || // e.g. \"text\", 42, true\n\t\t\tts.isTypeNode(node) // e.g. string, number, boolean\n\t\t) {\n\t\t\treturn [calledNode(node, callParent)];\n\t\t}\n\n\t\tconsole.warn('Unknown node type: ', node);\n\t\treturn [];\n\t}\n\n\tprivate collectConditionalTypeNode(\n\t\tnode: TS.ConditionalTypeNode\n\t): CalledNode[] {\n\t\treturn [\n\t\t\t...this.collectUnionMemberNodes(node.checkType, node),\n\t\t\t...this.collectUnionMemberNodes(node.extendsType, node),\n\t\t\t...this.collectUnionMemberNodes(node.trueType, node),\n\t\t\t...this.collectUnionMemberNodes(node.falseType, node),\n\t\t];\n\t}\n\n\tprivate collectIndexedAccessTypeNode(\n\t\tnode: TS.IndexedAccessTypeNode\n\t): CalledNode[] {\n\t\treturn [\n\t\t\t...this.collectUnionMemberNodes(node.objectType, node),\n\t\t\t...this.collectUnionMemberNodes(node.indexType, node),\n\t\t];\n\t}\n\n\tprivate collectTypeLiteralNode(node: TS.TypeLiteralNode): CalledNode[] {\n\t\treturn node.members\n\t\t\t.map((m) =>\n\t\t\t\t(m as any).type\n\t\t\t\t\t? this.collectUnionMemberNodes((m as any).type, node)\n\t\t\t\t\t: []\n\t\t\t)\n\t\t\t.flat();\n\t}\n\n\tprivate collectMappedTypeNode(node: TS.MappedTypeNode): CalledNode[] {\n\t\tconst results: TS.Node[] = [];\n\t\tif (node.typeParameter.constraint)\n\t\t\tresults.push(\n\t\t\t\t...this.collectUnionMemberNodes(node.typeParameter.constraint, node)\n\t\t\t);\n\t\tif (node.type)\n\t\t\tresults.push(...this.collectUnionMemberNodes(node.type, node));\n\t\treturn results;\n\t}\n\n\tprivate collectTypeReferenceNode(node: TS.TypeReferenceNode): CalledNode[] {\n\t\tconst checker = this.checker,\n\t\t\tts = this.ts,\n\t\t\tsymbol = checker.getSymbolAtLocation(node.typeName);\n\t\tif (!symbol) return [];\n\n\t\tconst aliasedSymbol =\n\t\t\tsymbol.flags & ts.SymbolFlags.Alias\n\t\t\t\t? checker.getAliasedSymbol(symbol)\n\t\t\t\t: symbol;\n\n\t\tconst decl = aliasedSymbol.declarations?.[0];\n\t\tif (!decl) return [];\n\t\tconst tn = ts.isTypeParameterDeclaration(decl)\n\t\t\t? decl.constraint ?? null\n\t\t\t: ts.isTypeAliasDeclaration(decl)\n\t\t\t? decl.type\n\t\t\t: null;\n\t\tif (!tn) return [];\n\t\treturn this.collectUnionMemberNodes(tn, node);\n\t}\n\n\tprivate collectKeyOfKeywordTypeOperatorNode(\n\t\tnode: TS.TypeOperatorNode,\n\t\tcallParent?: TS.Node\n\t): CalledNode[] {\n\t\tconst ts = this.ts,\n\t\t\tchecker = this.checker,\n\t\t\ttype = checker.getTypeAtLocation(node.type);\n\t\treturn type.getProperties().map((p) => {\n\t\t\tconst decl = p.getDeclarations()?.[0];\n\t\t\tconst litNode = ts.factory.createLiteralTypeNode(\n\t\t\t\tts.factory.createStringLiteral(p.getName())\n\t\t\t);\n\t\t\treturn calledNode(litNode, callParent, decl);\n\t\t});\n\t}\n\n\tprivate collectTupleTypeNode(node: TS.TupleTypeNode): CalledNode[] {\n\t\treturn node.elements\n\t\t\t.map((el) => this.collectUnionMemberNodes(el, node))\n\t\t\t.flat();\n\t}\n\n\tprivate collectTypeQueryNode(node: TS.TypeQueryNode): CalledNode[] {\n\t\tconst symbol = this.checker.getSymbolAtLocation(node.exprName);\n\t\tif (symbol) {\n\t\t\tconst decls = symbol.getDeclarations() ?? [];\n\t\t\treturn decls.flatMap((d) =>\n\t\t\t\tthis.collectUnionMemberNodes(d as TS.Node, node)\n\t\t\t);\n\t\t}\n\t\treturn [];\n\t}\n\n\tprivate createRegexNode(\n\t\tnode: TS.Node,\n\t\tregex: string,\n\t\tcallParent?: TS.Node\n\t): CalledNode {\n\t\tconst litNode = this.ts.factory.createStringLiteral(regex);\n\t\treturn calledNode(litNode, callParent, node, true);\n\t}\n\n\t// Creates new literal nodes with every possible content\n\tprivate buildTemplateLiteralNode(\n\t\tnode: TS.TemplateLiteralTypeNode,\n\t\tcallParent?: TS.Node\n\t): CalledNode[] {\n\t\tconst headText = escapeRegExp(node.head.text),\n\t\t\tts = this.ts;\n\t\tlet regexPattern = headText;\n\n\t\tfor (const span of node.templateSpans) {\n\t\t\tconst spanPatterns: string[] = [];\n\t\t\tconst innerTypeNodes = this.collectUnionMemberNodes(span.type, node);\n\n\t\t\tfor (const tn of innerTypeNodes) {\n\t\t\t\t// Literal: \"foo\" -> \"foo\"\n\t\t\t\tif (\n\t\t\t\t\tts.isLiteralTypeNode(tn) &&\n\t\t\t\t\t(this.ts.isStringLiteral(tn.literal) ||\n\t\t\t\t\t\tthis.ts.isNumericLiteral(tn.literal))\n\t\t\t\t)\n\t\t\t\t\tspanPatterns.push(escapeRegExp(String(tn.literal.text)));\n\t\t\t\t// number\n\t\t\t\telse if (tn.kind === ts.SyntaxKind.NumberKeyword)\n\t\t\t\t\tspanPatterns.push('\\\\d+(\\\\.\\\\d+)?');\n\t\t\t\t// boolean\n\t\t\t\telse if (tn.kind === ts.SyntaxKind.BooleanKeyword)\n\t\t\t\t\tspanPatterns.push('(true|false)');\n\t\t\t\t// string (caution: greedy)\n\t\t\t\telse if (tn.kind === ts.SyntaxKind.StringKeyword)\n\t\t\t\t\tspanPatterns.push('.*');\n\t\t\t\t// Fallback for unknown types\n\t\t\t\telse spanPatterns.push('.*');\n\t\t\t}\n\n\t\t\t// For multiple possibilities, use regex union pattern\n\t\t\tconst spanRegex =\n\t\t\t\tspanPatterns.length > 1\n\t\t\t\t\t? `(${spanPatterns.join('|')})`\n\t\t\t\t\t: spanPatterns[0];\n\n\t\t\tregexPattern += spanRegex + escapeRegExp(span.literal.text);\n\t\t}\n\n\t\treturn [node, this.createRegexNode(node, regexPattern, callParent)];\n\t}\n\n\tprivate cmp(expr: TS.Expression, node: CalledNode): boolean {\n\t\tconst ts = this.ts;\n\n\t\t// check for generated regex pattern\n\t\tif (isRegexPattern(node) && ts.isStringLiteral(expr)) {\n\t\t\t// Surround with ^...$, so the whole string must match\n\t\t\tconst pattern = new RegExp(`^${node.text}$`);\n\t\t\treturn pattern.test(expr.text);\n\t\t}\n\n\t\tif (!ts.isLiteralTypeNode(node)) return false;\n\n\t\tconst typeLiteral = node.literal;\n\n\t\t// string literals (i.e. \"hello\" and type T = \"hello\")\n\t\tif (ts.isStringLiteral(expr) && ts.isStringLiteral(typeLiteral))\n\t\t\treturn expr.text === typeLiteral.text;\n\n\t\t// numeric literals (i.e. 42 and type T = 42)\n\t\tif (ts.isNumericLiteral(expr) && ts.isNumericLiteral(typeLiteral))\n\t\t\treturn expr.text === typeLiteral.text;\n\n\t\t// BigInt literals (i.e. 100n and type T = 100n)\n\t\tif (ts.isBigIntLiteral(expr) && ts.isBigIntLiteral(typeLiteral))\n\t\t\treturn expr.text === typeLiteral.text;\n\n\t\t// booleans (compare kind of nodes)\n\t\tif (\n\t\t\t(expr.kind === ts.SyntaxKind.TrueKeyword &&\n\t\t\t\ttypeLiteral.kind === ts.SyntaxKind.TrueKeyword) ||\n\t\t\t(expr.kind === ts.SyntaxKind.FalseKeyword &&\n\t\t\t\ttypeLiteral.kind === ts.SyntaxKind.FalseKeyword)\n\t\t)\n\t\t\treturn true;\n\n\t\t// TODO: objects\n\n\t\t// null\n\t\tif (\n\t\t\texpr.kind === ts.SyntaxKind.NullKeyword &&\n\t\t\ttypeLiteral.kind === ts.SyntaxKind.NullKeyword\n\t\t)\n\t\t\treturn true;\n\n\t\t// undefined\n\t\tif (\n\t\t\texpr.kind === ts.SyntaxKind.UndefinedKeyword &&\n\t\t\ttypeLiteral.kind === ts.SyntaxKind.UndefinedKeyword\n\t\t)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n}\n\nfunction calledNode(\n\tnode: TS.Node,\n\tcallParent?: TS.Node,\n\toriginal?: TS.Node,\n\tisRegexPattern?: boolean\n): CalledNode {\n\tconst cNode = node as CalledNode;\n\tcNode.callParent = callParent as any;\n\tcNode.original = original;\n\tcNode.isRegexPattern = isRegexPattern;\n\treturn cNode;\n}\n\nfunction isRegexPattern(\n\tnode: CalledNode\n): node is TS.StringLiteral & CalledNode {\n\treturn node.isRegexPattern === true;\n}\n\nfunction escapeRegExp(string: string): string {\n\treturn string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n","import type * as TS from 'typescript/lib/tsserverlibrary';\nimport { addExtraJSDocTagInfo } from './docs';\nimport { TypeInfoFactory } from './info';\n\nexport class UnionTypeDocsPlugin {\n\tprivate logger!: TS.server.Logger;\n\tprivate ls!: TS.LanguageService;\n\tprivate proxy!: TS.LanguageService;\n\tprivate typeInfoFactory!: TypeInfoFactory;\n\n\tconstructor(private readonly ts: typeof TS) {}\n\n\tcreate(info: TS.server.PluginCreateInfo) {\n\t\tthis.logger = info.project.projectService.logger;\n\t\tthis.ls = info.languageService;\n\t\tthis.typeInfoFactory = new TypeInfoFactory(this.ts, this.ls)!;\n\t\tthis.proxy = createLsProxy(this.ls);\n\t\tthis.proxy.getQuickInfoAtPosition = this.getQuickInfoAtPosition.bind(this);\n\t\tthis.proxy.getCompletionsAtPosition =\n\t\t\tthis.getCompletionsAtPosition.bind(this);\n\t\tthis.logger.info('[Union type docs plugin] Loaded');\n\t\treturn this.proxy;\n\t}\n\n\tprivate getQuickInfoAtPosition(fileName: string, pos: number) {\n\t\tconst quickInfo = this.ls.getQuickInfoAtPosition(fileName, pos);\n\t\tif (!quickInfo) return quickInfo;\n\n\t\tconst typeInfo = this.typeInfoFactory.create(fileName, pos);\n\t\tif (!typeInfo) return quickInfo;\n\n\t\taddExtraJSDocTagInfo(this.ts, quickInfo, typeInfo);\n\n\t\treturn quickInfo;\n\t}\n\n\tprivate getCompletionsAtPosition(\n\t\tfileName: string,\n\t\tpos: number,\n\t\topts: TS.GetCompletionsAtPositionOptions | undefined,\n\t\tfmt?: TS.FormatCodeSettings\n\t): TS.WithMetadata<TS.CompletionInfo> | undefined {\n\t\tconst cmpl = this.ls.getCompletionsAtPosition(fileName, pos, opts, fmt);\n\n\t\treturn cmpl;\n\t}\n}\n\n// Create new object with all functions of the old language service\nfunction createLsProxy(oldLs: TS.LanguageService): TS.LanguageService {\n\tconst proxy = Object.create(null) as TS.LanguageService;\n\tfor (const k of Object.keys(oldLs) as Array<keyof TS.LanguageService>) {\n\t\tconst x = oldLs[k];\n\t\t(proxy as any)[k] = typeof x === 'function' ? x.bind(oldLs) : x;\n\t}\n\treturn proxy;\n}\n","import * as ts from 'typescript/lib/tsserverlibrary';\nimport { UnionTypeDocsPlugin } from './plugin';\n\nexport = (mod: { typescript: typeof ts }) =>\n  new UnionTypeDocsPlugin(mod.typescript);\n"],"names":["isRegexPattern"],"mappings":"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"}